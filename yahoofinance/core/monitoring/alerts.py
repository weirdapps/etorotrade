"""
Alert Management Module

This module provides components for managing alerts generated by threshold breaches
and monitoring conditions.
"""

import json
import logging
import os
import time
from dataclasses import dataclass, field
from threading import Lock
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Optional,
)

from yahoofinance.core.logging import get_logger
from .metrics import (
    metrics_registry,
    CounterMetric,
    GaugeMetric,
    HistogramMetric,
)


logger = get_logger(__name__)

# Directory for storing monitoring data files
MONITOR_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "data", "monitoring")
os.makedirs(MONITOR_DIR, exist_ok=True)


@dataclass
class Alert:
    """Alert generated when a threshold is breached."""

    name: str
    severity: str  # 'info', 'warning', 'error', 'critical'
    message: str
    value: float
    threshold: float
    timestamp: float = field(default_factory=time.time)
    tags: Dict[str, str] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert alert to dictionary format."""
        return {
            "name": self.name,
            "severity": self.severity,
            "message": self.message,
            "value": self.value,
            "threshold": self.threshold,
            "timestamp": self.timestamp,
            "tags": self.tags,
        }


class AlertManager:
    """Manage alerts generated by threshold breaches."""

    def __init__(self) -> None:
        """Initialize alert manager."""
        self._alerts: List[Alert] = []
        self._lock = Lock()
        self._alert_file = os.path.join(MONITOR_DIR, "alerts.json")
        self._handlers: Dict[str, Callable[[Alert], None]] = {}

        # Register default handlers
        self.register_handler("log", self._log_alert)
        self.register_handler("file", self._file_alert)

    def register_handler(self, name: str, handler: Callable[[Alert], None]) -> None:
        """Register an alert handler."""
        with self._lock:
            self._handlers[name] = handler

    def trigger_alert(self, alert: Alert) -> None:
        """Trigger an alert."""
        with self._lock:
            self._alerts.append(alert)

            # Call all registered handlers
            for handler in self._handlers.values():
                try:
                    handler(alert)
                except (RuntimeError, ValueError, TypeError, OSError, IOError) as e:
                    logger.error(f"Alert handler failed: {e}")

    def _log_alert(self, alert: Alert) -> None:
        """Log an alert."""
        log_method = getattr(logger, alert.severity.lower(), logger.warning)
        log_method(
            f"ALERT: {alert.name} - {alert.message} (value: {alert.value}, threshold: {alert.threshold})"
        )

    def _file_alert(self, alert: Alert) -> None:
        """Write alert to file."""
        try:
            # Load existing alerts
            alerts = []
            if os.path.exists(self._alert_file):
                with open(self._alert_file, "r") as f:
                    alerts = json.load(f)

            # Add new alert
            alerts.append(alert.to_dict())

            # Write alerts back to file
            with open(self._alert_file, "w") as f:
                json.dump(alerts, f, indent=2)
        except (OSError, IOError, json.JSONDecodeError, TypeError) as e:
            logger.error(f"Failed to write alert to file: {e}")

    def get_alerts(
        self, severity: Optional[str] = None, since: Optional[float] = None
    ) -> List[Alert]:
        """Get alerts filtered by severity and time."""
        with self._lock:
            filtered = self._alerts.copy()

            if severity:
                filtered = [a for a in filtered if a.severity == severity]

            if since:
                filtered = [a for a in filtered if a.timestamp >= since]

            return filtered

    def clear_alerts(self) -> None:
        """Clear all alerts."""
        with self._lock:
            self._alerts = []


# Global alert manager
alert_manager = AlertManager()


def check_metric_threshold(
    metric_name: str,
    threshold: float,
    comparison: str,  # 'gt', 'lt', 'ge', 'le', 'eq'
    severity: str,  # 'info', 'warning', 'error', 'critical'
    message_template: str,
) -> None:
    """
    Check if a metric breaches a threshold and trigger an alert if it does.

    Args:
        metric_name: Name of the metric to check
        threshold: Threshold value
        comparison: Comparison operator ('gt', 'lt', 'ge', 'le', 'eq')
        severity: Alert severity ('info', 'warning', 'error', 'critical')
        message_template: Template for alert message with {value} and {threshold} placeholders
    """
    metrics = metrics_registry.get_all_metrics()
    if metric_name not in metrics:
        logger.warning(f"Metric {metric_name} not found for threshold check")
        return

    metric = metrics[metric_name]
    value = 0.0

    # Extract value from different metric types
    if isinstance(metric, (CounterMetric, GaugeMetric)):
        value = float(metric.value)
    elif isinstance(metric, HistogramMetric):
        # For histograms, use the mean value
        if metric.values:
            value = sum(metric.values) / len(metric.values)

    # Perform comparison
    breached = False
    if comparison == "gt":
        breached = value > threshold
    elif comparison == "lt":
        breached = value < threshold
    elif comparison == "ge":
        breached = value >= threshold
    elif comparison == "le":
        breached = value <= threshold
    elif comparison == "eq":
        breached = value == threshold

    # Trigger alert if threshold is breached
    if breached:
        message = message_template.format(value=value, threshold=threshold)
        alert = Alert(
            name=f"{metric_name}_{comparison}_{threshold}",
            severity=severity,
            message=message,
            value=value,
            threshold=threshold,
            tags=metric.tags.copy(),
        )
        alert_manager.trigger_alert(alert)
